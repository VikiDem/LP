#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Демина В.А.

## Введение
Существует два основных подхода к решению логических задач: метод порождения и проверок и метод ветвей и границ. При использовании метода порождения и проверок, генерируется множество всех возможных решений, каждое из которых потом проверяется на истинность, через описанные в программе условия. Метод ветвей и границ работает практически с точностью наоборот. Решения генерируются на основе уже написанных условий, а после некоторые из них отсекаются в результате проверки. Из-за такого подхода программе написаная вторым методом будет работать быстрей. Пролог, в отличие от императивных языков, имеет возможность рассмотрения большого количества вариантов решений и выбора продходящих из них, поэтому для написания решателей логических задач он является более удобным.

## Задание

На одном международном конгрессе встретились 4 делегата из разных стран. Каждый из них владел двумя языками из 4 (английский, французский, немецкий, итальянский). Однако, оказалось, что не было такого языка, на котором они могли бы говорить вчетвером. И был только один язык, на котором могли вести беседу трое из них. Никто из делегатов не владеет французским и немецким языками одновременно. Хотя физик не говорит по-английски, он может служить переводчиком, если математик и биолог захотят поговорить друг с другом. Биолог говорит по-немецки и может говорить с химиком, хотя тот не знает ни одного немецкого слова. Физик, математик и химик не могут беседовать втроем на одном языке. Какими двумя языками владеет каждый из них?

## Принцип решения

Вводная часть:
```prolog
lang(eng).
lang(fr).
lang(ger).
lang(it).

langs([eng,fr,ger,it]).

translate(eng, 'английский').
translate(fr, 'французкий').
translate(ger, 'немецкий').
translate(it, 'итальянский').

delegat(Lang1, Lang2).

speak(delegat(Lang,_), Lang).
speak(delegat(_,Lang), Lang).

delegats([F,M,H,B]):-
speak(F, Lang),
speak(M, Lang),
speak(H, Lang),
speak(B, Lang).
```
Для начала напишем предикаты, хрянящие в себе информацию о делигатах и языках, на которых они говорят: список делигатов, языки которые они использует, сколько языков знают.

Условия:
```prolog
four_speak([F,M,H,B]):- %все (не) могут говорить на одном языке
speak(F, Lang), speak(M, Lang), speak(H, Lang), speak(B, Lang).


three_speak([F,M,H,B]):- %трое могут говорить на одном языке(но это не физик, математик и химик)
speak(F, Lang), speak(M, Lang), speak(B, Lang);
speak(F, Lang), speak(H, Lang), speak(B, Lang);
speak(M, Lang), speak(H, Lang), speak(B, Lang).

fmh_speak([F,M,H,B]):-
speak(M, Lang), speak(H, Lang), speak(F, Lang).%(но это не физик, математик и химик)

ger_fr([F,M,H,B]):- %(никто не) говорит на немецком и французком одновременно
speak(F, fr),speak(F, ger);
speak(M, fr),speak(M, ger);
speak(H, fr),speak(H, ger);
speak(B, fr),speak(B, ger).

b_and_h([_,_,H,B]):- %биолог может говорить с химиком,но не на немецком, хоть и знает его
speak(H, Lang), speak(B, Lang).

m_and_f([F,M,_,_]):- %физик может быть переводчиком между математиком и биологом
speak(F, Lang), speak(M, Lang).
b_and_f([F,_,_,B]):-
speak(F, Lang), speak(B, Lang).
b_and_m([_,M,_,B]):- %биолог и математик не говорят на одном языке, тк им нужен переводчик
speak(M, Lang), speak(B, Lang).

not_double(Lang1, Lang2, [Lang1|Res]) :-
member(Lang2, Res).
not_double(Lang1, Lang2, [X|Res]) :-
not_double(Lang1, Lang2, Res).
```
Далее напишем несколько предикатов для сложных условий, требующех более одного простого высказывания.

Основная часть:
```prolog
solve():-
Delegats = [F,M,H,B],
F = delegat(LangF1, LangF2),
M = delegat(LangM1, LangM2),
H = delegat(LangH1, LangH2),
B = delegat(LangB1, LangB2),

langs(Langs),
lang(LangF1),lang(LangF2), not_double(LangF1,LangF2, Langs),
lang(LangM1),lang(LangM2), not_double(LangM1,LangM2, Langs), 
lang(LangH1),lang(LangH2), not_double(LangH1,LangH2, Langs), 
lang(LangB1),lang(LangB2), not_double(LangB1,LangB2, Langs),  

not(speak(F, eng)),
not(speak(H, ger)),
speak(B, ger),

not(four_speak(Delegats)),
three_speak(Delegats),
not(fmh_speak(Delegats)),
not(ger_fr(Delegats)),
not(b_and_m(Delegats)),
b_and_f(Delegats),
m_and_f(Delegats),
b_and_h(Delegats),

translate(LangF1, F1), translate(LangF2, F2),
translate(LangM1, M1), translate(LangM2, M2),
translate(LangH1, H1), translate(LangH2, H2),
translate(LangB1, B1), translate(LangB2, B2),

write('Физик: '), write(F1), write(', '), write(F2), nl,
write('Математик: '), write(M1), write(', '), write(M2), nl,
write('Химик: '), write(H1), write(', '), write(H2), nl,
write('Биолог: '), write(B1), write(', '), write(B2), nl.
```
Последним же идет предикат, который будет выдавать нам уже готовый ответ. Его можно разделить на три основные части: информация о делегатах, условия, вывод ответа.

Результат работы программы:
```prolog
?- solve().
Физик: французкий, итальянский
Математик: английский, французкий
Химик: английский, итальянский
Биолог: немецкий, итальянский
true ;
false.
```
Как мы видим, программы выдает единственный ответ, который соответсвует всем заданным условиям из чего можно сделать вывод, что результат работы программы правильный.

## Выводы

Во время выполнения работы, возникла ситуация, когда программа выводила более одного решения. Чтобы разобраться почему это происходит, пришлось самостоятельно решить задачу и найти недостающее условие(биолог и математик не говорят на одном языке, тк им нужен переводчик), а так же исправить условие которое не работало. После решения возникшей проблеммы я могу сказать, что для написания программ-решателей логических задач необходимо понимать, как именно решаются эти задачи, а иногда и вовсе прорешивать их. Однако, не смотря на это, я считаю что использование пролога(как представителя логических языков) для выполнения данной задачи, подходит как нельзя лучше. По сравнению с императивными языками программирования написание кода занимает меньше времени, так как для решения этой задачи нужно передать программе на прологе те же условия, что и человеку, достаточно просто "перевести" их на язык программы. При использовании императивных языков пришлось бы долго ломать голову над тем, как записать эти условия, при использовании логического языка такая проблемма отсутствует.


