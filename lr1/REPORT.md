# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Демина В.А.


## Введение
Робота со списками в прологе во многом отличается от привычной многим в императивных языкох. Представляются списки с помощью системы Голова-Хвост, схожей с привчными нам стеком или бинарным деревом в одной ветви которого хранится голова, а в другой хвост, разделенный, в свою очередь, на голову и другой хвост. Чтобы получить доступ к данным мы используем не итераторы, а специальные функции - предикаты, которые работают со списками с помощью рекурсии. Так же элементы списка в Прологе могут иметь разный тип данных, что невозможно для списков в императивных языках.


## Задание 1.1: Предикат обработки списка

`last(List, Val, Res)` - добавляет элемент в конец списка

Примеры использования:
```prolog
?- last([1,2,3],4,X).
X=[1,2,3,4].
?- last([1,2,3,4],2, [1,2,3,4,5]).
false.
```

Реализация:
```prolog
last([], X, [X]).
last([H|A], X, [H|B]):- last(A,X,B).
```

Реализация c использованием стандартных предикатов:
```prolog
last2(A, Val, X):- append(A, [Val], X).
```
С помощью рекурсии предикат сначала копирует все элементы, будто бы удаляя их, до того момента, пока список не будет пуст. После этого единственным элементом списка становится новый элемен, а "удаленные" до этого элементы рекурсивно вставляются назад. В реализации со стандартными предикатами мы используем для этого конкатенацию списков.

## Задание 1.2: Предикат обработки числового списка

`prograssion(List)` - проверяет, является ли список арифметической прогрессией 

Примеры использования:
```prolog
?- prograssion([2,5,8,11]).
true .
?- prograssion([1,5,6]).
false.
```

Реализация:
```prolog
prograssion([]). 
prograssion(N, D, [N]).
prograssion(N, D, [N|T]):- N1 is N + D, prograssion(N1, D, T).
prograssion([A,B|T]):- D is B - A, prograssion(A, D, [A, B|T]).
```

Реализация c использованием стандартных предикатов:
```prolog
prograssion2([]).
prograssion2(N, D, [N]).
prograssion2(N, D, [A, B|T]):-member(N, [A]), D1 is N+D, prograssion2(D1, D, [B|T]).
prograssion2([A, B|T]):- D is B - A, prograssion2(A, D, [A, B|T]).
```
Сначала вычисляется d(разность арифметической прогрессии) и находится первый и второй член прогрессии, после чего предикат начинает сравнивать сумму d+первый член прогрессии со вторым членом, если они оказываются равны, второй член прогрессии становится первым, а третий вторым и сравнивание продолжается. В реализации со стандартным предикатом мы испобзуем проверку принадлежности к списку: к первому члену прогрессии каждый раз прибавляется d и сравнивается со вторым.

## Задание 2: Реляционное представление данных
Преимуществом такого метода является простотапонимания и легкость в отслеживании связей между данными, недостатком же являются затраты памяти.

Вариант 1
Получить таблицу групп и средний балл по каждой из групп
Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
Найти количество не сдавших студентов в каждой из групп

Общая часть:
```prolog
:- ['one.pl'].

sum([], 0). %сумма элементов списка
sum([H|T], Sum):- sum(T, Sum1), Sum is Sum1 + H.

length([], 0). %длина списка ​
length([_|Y], N) :- length(Y, N1), N is N1 + 1. 

member(A, [A|_]).​ %принадлежность списку
member(A, [_|Z]) :- member(A, Z).
```
Для написания программы нам понадобится файлик `one.pl`, а так же стандартные предикаты `length` и `member` и предикат для вычисления суммы.

Реализация первого пункта:
```prolog
%Получить таблицу групп и средний балл по каждой из групп
group(X,L) :- findall(Z,student(X,Z),L). %для вывода таблицы групп

marks_of_group(Group, Mark):- student(Group,Student), grade(Student,_,Mark). %перевод в функцию(группа, оценка) 

mean_group(Group, Res):- %средний балл группы
findall(Mark,marks_of_group(Group, Mark),Marks),
sum(Marks, A),
length(Marks, B),
Res is A / B.


first():-
group(101,X1),
write('Группа 101: '), write(X1), nl,
mean_group(101, Y1),
write('Средний балл: '), write(Y1), nl,

group(102,X2),
write('Группа 102: '), write(X2), nl,
mean_group(102, Y2),
write('Средний балл: '), write(Y2), nl,

group(103,X3),
write('Группа 103: '), write(X3), nl,
mean_group(103, Y3),
write('Средний балл: '), write(Y3), nl,

group(104,X4),
write('Группа 104: '), write(X4), nl,
mean_group(104, Y4),
write('Средний балл: '), write(Y4), nl.
```
Для нахождения среднего балла группы создаем функцию, хранящую в себе только группу и оценки. С помощью нее находим сначала сумму всех оценок определенной групы, а потом их колличество, делим первое на второе и получаем нужный ответ. Для составления таблици используем `findall`, который создает список всех студентов определенной группы.

Результат работы:
```prolog
?- first.
Группа 101: [Петровский,Сидоров,Мышин,Безумников,Густобуквенникова]
Средний балл: 3.9
Группа 102: [Петров,Ивановский,Биткоинов,Шарпин,Эксель,Текстописов,Криптовалютников,Азурин,Круглотличников]
Средний балл: 3.7777777777777777
Группа 103: [Сидоркин,Эфиркина,Сиплюсплюсов,Программиро,Клавиатурникова,Решетников,Текстописова,Вебсервисов]
Средний балл: 3.7708333333333335
Группа 104: [Иванов,Запорожцев,Джаво,Фулл,Круглосчиталкин,Блокчейнис]
Средний балл: 3.861111111111111
true.
```



Реализация второго пункта:
```prolog
%Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
fail_subject(Sub, Res):- 
findall(Student,grade(Student,Sub,2),Res).


second():-
write('Студенты не сдавшие экзамен:  '), nl,

fail_subject('LP', St1),
write('Логическое программирование - '), write(St1), nl,

fail_subject('MTH', St2),
write('Математический анализ - '), write(St2), nl,

fail_subject('FP', St3),
write('Функциональное программирование - '), write(St3), nl,

fail_subject('INF', St4),
write('Информатика - '), write(St4), nl,

fail_subject('ENG', St5),
write('Английский язык - '), write(St5), nl,

fail_subject('PSY', St6),
write('Психология - '), write(St6), nl.
```
Для нахождения несдавших студентов, выполняем поиск по предмету и оценкам(смотрим только на 2).Для вывода списка студентов используем `findall`.

Результат работы:
```prolog
?- second.
Студенты не сдавшие экзамен:
Логическое программирование - [Запорожцев,Эфиркина,Текстописов]
Математический анализ - [Запорожцев,Круглосчиталкин,Густобуквенникова,Криптовалютников,Блокчейнис,Азурин]
Функциональное программирование - [Криптовалютников]
Информатика - [Эфиркина,Джаво,Безумников]
Английский язык - [Эфиркина]
Психология - [Биткоинов,Текстописова,Криптовалютников,Азурин,Вебсервисов]
true.
```



Реализация третьего пункта:
```prolog
%Найти количество не сдавших студентов в каждой из групп
fail_in_group(Group, 2, Student):- grade(Student,_,2), student(Group, Student).%для удобства 

remove_copy([], []). %удаляет повторы 
remove_copy([A|B], C):- member(A, B), !, remove_copy(B, C).
remove_copy([A|B], [A|C]):- !, remove_copy(B, C).


n_fail_in_group(Group, N):-
findall(Student,fail_in_group(Group, 2, Student),Students),
remove_copy(Students, Res),
length(Res, N).

third():-
n_fail_in_group(101, N1),
write('Не сдавших в 101 группе: '), write(N1), nl,

n_fail_in_group(102, N2),
write('Не сдавших в 102 группе: '), write(N2), nl,

n_fail_in_group(103, N3),
write('Не сдавших в 103 группе: '), write(N3), nl,

n_fail_in_group(104, N4),
write('Не сдавших в 104 группе: '), write(N4), nl.
```
Так же как и в первом пункте, создаем дополнительную функцию для хранения в ней группы, студента и оценки. С помощью нее находим всех студентов не сдавших какой-либо предмет, содаем списки по группам и с помощью дополнительного предиката `remove_copy` избавляемся от повторений в этих списках. После этого считаем количество элементов в списке.

Результат работы:
```prolog
?- third.
Не сдавших в 101 группе: 2
Не сдавших в 102 группе: 4
Не сдавших в 103 группе: 3
Не сдавших в 104 группе: 4
true.
```
## Выводы
После этой лабораторной работы, я не только научилась работе со списками, но и стала лучше понимать пролог и его отличие от императивных языков. Работа со списками давольно сильно отличаются от привычных мне методов, поэтому для выполнения некоторых задач пришлось поломать голову. В первом задании возникли сложности с реализацией обработки числовых списков через стандартные предикаты. Долго не могла придумать какой именно взять, и как его использовать для нахождения решения. Так же возникли проблемы с удалением повторяющихся элементов списка в третьем пункте второго задания. Пришлось воспользоваться интернетом, чтобы разобраться с некоторыми вещами. Однако думаю, что приобретенные знания понадабятся мне в будующем, как минимум для других лабораторных работ по данному курсу.
